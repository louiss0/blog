import * as _markdoc_markdoc from '@markdoc/markdoc';
import { ValidationError, Scalar, Config, ValidationType, SchemaAttribute, Node } from '@markdoc/markdoc';

interface CustomAttributeTransformContract {
    transform(value: NonNullable<unknown>, config: Config): Scalar;
}
interface CustomAttributeValidationContract {
    validate(value: unknown, config: Config): ValidationError[];
}
declare abstract class MarkdocValidatorAttribute implements CustomAttributeValidationContract {
    validate(value: unknown, config: Config): ValidationError[];
    abstract returnMarkdocErrorObjectOrNothing(value: unknown, config: Config): ValidationError | void;
}
declare class MediaAttribute extends MarkdocValidatorAttribute {
    private readonly deviceOperatorAndOrientationRegex;
    private readonly deviceOperatorAndAspectRatioRegex;
    private readonly deviceOperatorAndMediaQueryRegex;
    private readonly deviceOperatorAndColorOrColorIndexRegex;
    private readonly deviceOperatorAndMonoChromeRegex;
    private readonly deviceOperatorAndResolutionRegex;
    private readonly deviceOperatorAndGridRegex;
    private readonly deviceOperatorAndScanRegex;
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}
declare class SourceAttribute extends MarkdocValidatorAttribute {
    private readonly httpUrlAttribute;
    private readonly pathAttribute;
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}
declare class DownloadAttribute extends MarkdocValidatorAttribute {
    private readonly pathAttribute;
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}
declare class SrcSetAttribute extends MarkdocValidatorAttribute implements CustomAttributeTransformContract {
    constructor();
    protected readonly relativePathAndEitherViewportWidthOrWidthSizeRegex: RegExp;
    protected readonly relativePathAndPixelDensityRegex: RegExp;
    protected readonly absolutePathAndEitherViewportWidthOrWidthSizeRegex: RegExp;
    protected readonly absolutePathAndPixelDensityRegex: RegExp;
    transform(value: unknown): Scalar;
    private checkIfStringIsValid;
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}
declare class SizesAttribute extends MarkdocValidatorAttribute implements CustomAttributeTransformContract {
    private readonly mediaSizesAttribute;
    transform(value: Array<string>): Scalar;
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}
declare class IntegerAttribute extends MarkdocValidatorAttribute {
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}

type RequiredSchemaAttribute = Extract<ValidationType, Object>;
type ProperSchemaMatches<T extends RequiredSchemaAttribute> = T extends StringConstructor ? ReadonlyArray<string> | RegExp : T extends NumberConstructor ? ReadonlyArray<number> : T extends Boolean ? boolean : never;
type ProperDefaultValue<T extends RequiredSchemaAttribute> = T extends StringConstructor ? string : T extends NumberConstructor ? number : T extends Boolean ? boolean : T extends ObjectConstructor ? Record<string, Scalar> : never;
type MarkdocAttributeSchema<T extends RequiredSchemaAttribute> = {
    type: T;
    default?: ProperDefaultValue<T>;
    matches?: ProperSchemaMatches<T>;
    required?: true;
} & Omit<SchemaAttribute, "matches" | "default" | "type" | "validate" | "required">;
type PrimaryMarkdocAttributeSchema<T extends RequiredSchemaAttribute> = MarkdocAttributeSchema<T> & Record<"render" | "required", true>;
type SchemaAttributesWithAPrimaryKey<T extends RequiredSchemaAttribute> = {
    primary?: PrimaryMarkdocAttributeSchema<T>;
} & Record<string, MarkdocAttributeSchema<T>>;
type SchemaAttributesWithNoPrimaryKey<T extends RequiredSchemaAttribute> = {
    primary?: never;
} & Record<string, MarkdocAttributeSchema<T>>;
declare namespace MarkdocAttributes {
    const style: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: {
            new (): {
                transform(value: Record<string, string | number>): Scalar;
                returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                validate(value: unknown, config: Readonly<Partial<{
                    nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                    tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                    variables: Record<string, any>;
                    functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                    partials: Record<string, any>;
                    validation?: {
                        validateFunctions?: boolean | undefined;
                    } | undefined;
                }>>): ValidationError[];
            };
        };
        required: true | undefined;
        errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
    }>;
    const target: Readonly<{
        description: string | undefined;
        render: string | boolean | undefined;
        matches: readonly ["_target", "_blank", "_parent", "_top"];
        default: string | number | Record<string, Scalar> | undefined;
        type: StringConstructor;
        required: true | undefined;
        errorLevel: "error";
    }>;
    const tabindex: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: typeof IntegerAttribute;
        required: true | undefined;
        errorLevel: "error";
    }>;
    const hidden: Readonly<{
        description: string | undefined;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: BooleanConstructor;
        required: true | undefined;
        errorLevel: "error";
    }>;
    const referrerpolicy: Readonly<{
        description: string | undefined;
        render: string | boolean | undefined;
        matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin-when-cross-origin", "unsafe-url"];
        default: string | number | Record<string, Scalar> | undefined;
        type: StringConstructor;
        required: true | undefined;
        errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
    }>;
    const title: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: {
            new (): {
                returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                    id: string;
                    level: "error" | "debug" | "info" | "warning" | "critical";
                    message: string;
                    location: _markdoc_markdoc.Location;
                } | {
                    id: string;
                    level: "error" | "debug" | "info" | "warning" | "critical";
                    message: string;
                    location?: undefined;
                }> | undefined;
                validate(value: unknown, config: Readonly<Partial<{
                    nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                    tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                    variables: Record<string, any>;
                    functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                    partials: Record<string, any>;
                    validation?: {
                        validateFunctions?: boolean | undefined;
                    } | undefined;
                }>>): ValidationError[];
            };
        };
        required: true | undefined;
        errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
    }>;
    const width: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: typeof IntegerAttribute;
        required: true | undefined;
        errorLevel: "warning";
    }>;
    const height: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: typeof IntegerAttribute;
        required: true | undefined;
        errorLevel: "warning";
    }>;
    const cite: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: typeof SourceAttribute;
        required: true | undefined;
        errorLevel: "warning";
    }>;
    const datetime: Readonly<{
        description: string;
        render: string | boolean | undefined;
        matches: RegExp | readonly string[] | readonly number[] | undefined;
        default: string | number | Record<string, Scalar> | undefined;
        type: {
            new (): {
                returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                validate(value: unknown, config: Readonly<Partial<{
                    nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                    tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                    variables: Record<string, any>;
                    functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                    partials: Record<string, any>;
                    validation?: {
                        validateFunctions?: boolean | undefined;
                    } | undefined;
                }>>): ValidationError[];
            };
        };
        required: true | undefined;
        errorLevel: "warning";
    }>;
    const translate: Readonly<{
        description: string;
        matches: readonly ["yes", "no"];
        type: StringConstructor;
        errorLevel: "error";
    }>;
    const lang: Readonly<{
        description: string;
        matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
        type: StringConstructor;
        errorLevel: "error";
    }>;
    const dir: Readonly<{
        description: string;
        matches: readonly ["auto", "ltr", "rtl"];
        type: StringConstructor;
        errorLevel: "error";
    }>;
    const draggable: Readonly<{
        description: string;
        type: BooleanConstructor;
        errorLevel: "error";
    }>;
    const spellcheck: Readonly<{
        description: string;
        type: BooleanConstructor;
        errorLevel: "error";
    }>;
    const contenteditable: Readonly<{
        description: string;
        type: BooleanConstructor;
        errorLevel: "error";
    }>;
}

declare const abbr: Readonly<{
    description: "A tag that automatically creates an abbreviation of a capitalised word";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
        readonly title: {
            readonly type: StringConstructor;
            readonly errorLevel: "error";
            readonly matches: RegExp;
        };
    };
    render: "abbr";
    selfClosing: true;
}> | Readonly<{
    readonly render: "abbr";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
        readonly title: {
            readonly type: StringConstructor;
            readonly errorLevel: "error";
            readonly matches: RegExp;
        };
    };
    readonly description: "A tag that automatically creates an abbreviation of a capitalised word";
} & {
    selfClosing: true;
}>;

declare const sup: Readonly<{
    description: "A schema for creating a sup element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "sup";
    selfClosing: true;
}> | Readonly<{
    readonly render: "sup";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a sup element";
} & {
    selfClosing: true;
}>;
declare const li: Readonly<{
    inline: false;
    description: "A schema for creating a sup element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "li";
    selfClosing: true;
}> | Readonly<{
    readonly render: "li";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a sup element";
    readonly inline: false;
} & {
    selfClosing: true;
}>;
declare const small: Readonly<{
    description: "A schema for creating a sup element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "small";
    selfClosing: true;
}> | Readonly<{
    readonly render: "small";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a sup element";
} & {
    selfClosing: true;
}>;
declare const del: Readonly<{
    description: "A schema for creating a del element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
        readonly cite: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof SourceAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly datetime: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    render: "del";
    selfClosing: true;
}> | Readonly<{
    readonly render: "del";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
        readonly cite: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof SourceAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly datetime: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    readonly description: "A schema for creating a del element";
} & {
    selfClosing: true;
}>;
declare const ins: Readonly<{
    description: "A schema for creating a ins element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
        readonly cite: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof SourceAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly datetime: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    render: "ins";
    selfClosing: true;
}> | Readonly<{
    readonly render: "ins";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
        readonly cite: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof SourceAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly datetime: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    readonly description: "A schema for creating a ins element";
} & {
    selfClosing: true;
}>;
declare const sub: Readonly<{
    description: "A schema for creating a sub element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "sub";
    selfClosing: true;
}> | Readonly<{
    readonly render: "sub";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a sub element";
} & {
    selfClosing: true;
}>;
declare const code: Readonly<{
    description: "A schema for creating a code element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "code";
    selfClosing: true;
}> | Readonly<{
    readonly render: "code";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a code element";
} & {
    selfClosing: true;
}>;
declare const samp: Readonly<{
    description: "A schema for creating a samp element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "samp";
    selfClosing: true;
}> | Readonly<{
    readonly render: "samp";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a samp element";
} & {
    selfClosing: true;
}>;
declare const mark: Readonly<{
    description: "A schema for creating a mark element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "mark";
    selfClosing: true;
}> | Readonly<{
    readonly render: "mark";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a mark element";
} & {
    selfClosing: true;
}>;
declare const q: Readonly<{
    description: "A schema for creating a q element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "q";
    selfClosing: true;
}> | Readonly<{
    readonly render: "q";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a q element";
} & {
    selfClosing: true;
}>;
declare const kbd: Readonly<{
    description: "A schema for creating a kbd element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "kbd";
    selfClosing: true;
}> | Readonly<{
    readonly render: "kbd";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a kbd element";
} & {
    selfClosing: true;
}>;
declare const bdo: Readonly<{
    description: "A schema for creating a bdo element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "bdo";
    selfClosing: true;
}> | Readonly<{
    readonly render: "bdo";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a bdo element";
} & {
    selfClosing: true;
}>;
declare const bdi: Readonly<{
    description: "A schema for creating a bdi element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "bdi";
    selfClosing: true;
}> | Readonly<{
    readonly render: "bdi";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a bdi element";
} & {
    selfClosing: true;
}>;
declare const data: Readonly<{
    description: "A schema for creating a data element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "data";
    selfClosing: true;
}> | Readonly<{
    readonly render: "data";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a data element";
} & {
    selfClosing: true;
}>;
declare const dd: Readonly<{
    inline: false;
    description: "A schema for creating a dd element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "dd";
    selfClosing: true;
}> | Readonly<{
    readonly render: "dd";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly inline: false;
    readonly description: "A schema for creating a dd element";
} & {
    selfClosing: true;
}>;
declare const dt: Readonly<{
    inline: false;
    description: "A schema for creating a dt element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "dt";
    selfClosing: true;
}> | Readonly<{
    readonly render: "dt";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly inline: false;
    readonly description: "A schema for creating a dt element";
} & {
    selfClosing: true;
}>;
declare const span: Readonly<{
    description: "A schema for creating a span element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "span";
    selfClosing: true;
}> | Readonly<{
    readonly render: "span";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a span element";
} & {
    selfClosing: true;
}>;
declare class TimeAttribute extends MarkdocValidatorAttribute {
    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
}
declare const time: Readonly<{
    inline: false;
    description: "A schema for creating a time element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: typeof TimeAttribute;
        };
        readonly datetime: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    render: "time";
    selfClosing: true;
}> | Readonly<{
    readonly render: "time";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: typeof TimeAttribute;
        };
        readonly datetime: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    readonly description: "A schema for creating a time element";
    readonly inline: false;
} & {
    selfClosing: true;
}>;
declare const summary: Readonly<{
    inline: false;
    description: "This is the summary for the details tag";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "summary";
    selfClosing: true;
}> | Readonly<{
    readonly render: "summary";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "This is the summary for the details tag";
    readonly inline: false;
} & {
    selfClosing: true;
}>;
declare const dfn: Readonly<{
    inline: false;
    description: "A schema for creating a dfn element";
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
    attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    render: "dfn";
    selfClosing: true;
}> | Readonly<{
    readonly render: "dfn";
    readonly attributes: {
        readonly primary: {
            readonly required: true;
            readonly render: true;
            readonly type: StringConstructor;
        };
    };
    readonly description: "A schema for creating a dfn element";
    readonly inline: false;
} & {
    selfClosing: true;
}>;

declare class AllowAttribute extends MarkdocValidatorAttribute implements CustomAttributeTransformContract {
    transform(value: Record<string, string>): string;
    readonly allowedPermissionDirectives: string[];
    readonly keywordAndOriginGroupsRegex: RegExp;
    readonly anchoredStarRegex: RegExp;
    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
        id: string;
        level: "error" | "debug" | "info" | "warning" | "critical";
        message: string;
        location: _markdoc_markdoc.Location;
    } | {
        id: string;
        level: "error" | "debug" | "info" | "warning" | "critical";
        message: string;
        location?: undefined;
    }> | undefined;
}
declare const iframe: Readonly<{
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly required: true;
            readonly description: "This attribute is the path to the place containing media to display";
        };
        readonly allow: {
            readonly type: typeof AllowAttribute;
            readonly description: "An attribute that makes sure that the user creates an object.\n            The allowed allowedPermissionDirectives as keys.\n            The values for them as values.\n            ";
        };
        readonly name: {
            readonly type: StringConstructor;
            readonly description: "The name of the iframe";
        };
        readonly loading: {
            readonly type: StringConstructor;
            readonly matches: readonly ["eager", "lazy"];
        };
        readonly sandbox: {
            readonly type: StringConstructor;
            readonly matches: readonly ["allow-downloads", "allow-forms", "allow-modals", "allow-orientation-lock", "allow-pointer-lock", "allow-popups", "allow-popups-to-escape-sandbox", "allow-same-origin", "allow-scripts", "allow-top-navigation", "allow-top-navigation-by-user-activation", "allow-top-navigation-to-custom-protocols"];
        };
        readonly width: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly height: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    render: "iframe";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: _markdoc_markdoc.Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    attributes: {
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly required: true;
            readonly description: "This attribute is the path to the place containing media to display";
        };
        readonly allow: {
            readonly type: typeof AllowAttribute;
            readonly description: "An attribute that makes sure that the user creates an object.\n            The allowed allowedPermissionDirectives as keys.\n            The values for them as values.\n            ";
        };
        readonly name: {
            readonly type: StringConstructor;
            readonly description: "The name of the iframe";
        };
        readonly loading: {
            readonly type: StringConstructor;
            readonly matches: readonly ["eager", "lazy"];
        };
        readonly sandbox: {
            readonly type: StringConstructor;
            readonly matches: readonly ["allow-downloads", "allow-forms", "allow-modals", "allow-orientation-lock", "allow-pointer-lock", "allow-popups", "allow-popups-to-escape-sandbox", "allow-same-origin", "allow-scripts", "allow-top-navigation", "allow-top-navigation-by-user-activation", "allow-top-navigation-to-custom-protocols"];
        };
        readonly width: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly height: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
    };
    render: "iframe";
    selfClosing: true;
}>;

declare class HrefAttribute extends MarkdocValidatorAttribute {
    private readonly httpUrlAttribute;
    private readonly pathAttribute;
    readonly mailtoRegex: RegExp;
    readonly telRegex: RegExp;
    readonly routePathRegex: RegExp;
    readonly wordThatStartsWithAHashRegex: RegExp;
    returnMarkdocErrorObjectOrNothing(value: string): ValidationError | void;
}
declare const a: Readonly<{
    children: readonly ["tag", "text", "strong", "em", "image", "paragraph"];
    transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly href: {
            readonly type: typeof HrefAttribute;
            readonly required: true;
        };
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly target: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: readonly ["_target", "_blank", "_parent", "_top"];
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: StringConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly type: {
            readonly type: StringConstructor;
            readonly matches: RegExp;
        };
        readonly rel: {
            readonly type: StringConstructor;
            readonly matches: readonly ["alternate", "author", "bookmark", "external", "help", "license", "next", "nofollow", "noreferrer", "noopener", "prev", "search", "tag"];
        };
        readonly reffererpolicy: {
            readonly type: StringConstructor;
            readonly matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin", "strict-origin-when-cross-origin", "unsafe-url"];
        };
        readonly download: {
            readonly type: typeof DownloadAttribute;
            readonly errorLevel: "error";
            readonly description: "Allows the user to download a file from the computer or the project file system";
        };
    };
    render: "a";
    validate: (node: _markdoc_markdoc.Node) => ValidationError[];
}> | Readonly<{
    children: readonly ["tag", "text", "strong", "em", "image", "paragraph"];
    attributes: {
        readonly href: {
            readonly type: typeof HrefAttribute;
            readonly required: true;
        };
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly target: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: readonly ["_target", "_blank", "_parent", "_top"];
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: StringConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly type: {
            readonly type: StringConstructor;
            readonly matches: RegExp;
        };
        readonly rel: {
            readonly type: StringConstructor;
            readonly matches: readonly ["alternate", "author", "bookmark", "external", "help", "license", "next", "nofollow", "noreferrer", "noopener", "prev", "search", "tag"];
        };
        readonly reffererpolicy: {
            readonly type: StringConstructor;
            readonly matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin", "strict-origin-when-cross-origin", "unsafe-url"];
        };
        readonly download: {
            readonly type: typeof DownloadAttribute;
            readonly errorLevel: "error";
            readonly description: "Allows the user to download a file from the computer or the project file system";
        };
    };
    render: "a";
}>;

declare const source: Readonly<{
    description: "This is the schema for the HTML source tag";
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly description: "A set of urls and image sizes that are required to use upload the picture";
        };
        readonly srcset: {
            readonly type: typeof SrcSetAttribute;
            readonly description: "A set of urls and image sizes that are required to use upload the picture";
        };
        readonly sizes: {
            readonly type: typeof SizesAttribute;
            readonly description: "The size of each image in a media query";
            readonly errorLevel: "warning";
        };
        readonly media: {
            readonly type: typeof MediaAttribute;
            readonly description: "The art resolution or time for an image to appear in a media query";
            readonly errorLevel: "warning";
        };
        readonly type: {
            readonly type: StringConstructor;
            readonly errorLevel: "warning";
            readonly description: "The type of image that is being used";
        };
    };
    render: "source";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    description: "This is the schema for the HTML source tag";
    attributes: {
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly description: "A set of urls and image sizes that are required to use upload the picture";
        };
        readonly srcset: {
            readonly type: typeof SrcSetAttribute;
            readonly description: "A set of urls and image sizes that are required to use upload the picture";
        };
        readonly sizes: {
            readonly type: typeof SizesAttribute;
            readonly description: "The size of each image in a media query";
            readonly errorLevel: "warning";
        };
        readonly media: {
            readonly type: typeof MediaAttribute;
            readonly description: "The art resolution or time for an image to appear in a media query";
            readonly errorLevel: "warning";
        };
        readonly type: {
            readonly type: StringConstructor;
            readonly errorLevel: "warning";
            readonly description: "The type of image that is being used";
        };
    };
    render: "source";
    selfClosing: true;
}>;
declare const track: Readonly<{
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly required: true;
            readonly description: "The url where the file is placed";
        };
        readonly default: {
            readonly type: BooleanConstructor;
        };
        readonly label: {
            readonly type: StringConstructor;
        };
        readonly srclang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly kind: {
            readonly type: StringConstructor;
            readonly matches: readonly ["captions", "chapters", "descriptions", "metadata", "subtitles"];
        };
    };
    render: "track";
    selfClosing: true;
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    attributes: {
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly required: true;
            readonly description: "The url where the file is placed";
        };
        readonly default: {
            readonly type: BooleanConstructor;
        };
        readonly label: {
            readonly type: StringConstructor;
        };
        readonly srclang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly kind: {
            readonly type: StringConstructor;
            readonly matches: readonly ["captions", "chapters", "descriptions", "metadata", "subtitles"];
        };
    };
    render: "track";
    selfClosing: true;
}>;
declare const hr: Readonly<{
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "hr";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "hr";
    selfClosing: true;
}>;
declare const br: Readonly<{
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "br";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "br";
    selfClosing: true;
}>;
declare const img: Readonly<{
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly width: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly height: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly referrerpolicy: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin-when-cross-origin", "unsafe-url"];
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: StringConstructor;
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly required: true;
            readonly errorLevel: "critical";
            readonly description: "The src of the image you want to see";
        };
        readonly alt: {
            readonly type: StringConstructor;
            readonly required: true;
            readonly errorLevel: "critical";
            readonly description: "The description of the image";
        };
        readonly srcset: {
            readonly type: typeof SrcSetAttribute;
            readonly description: "A set of urls and image sizes that are required to use upload the picture";
            readonly errorLevel: "warning";
        };
        readonly sizes: {
            readonly type: typeof SizesAttribute;
            readonly description: "The size of each image in a media query";
            readonly errorLevel: "warning";
        };
        readonly crossorigin: {
            readonly type: StringConstructor;
            readonly errorLevel: "critical";
            readonly matches: readonly ["anonymous", "use-credentials"];
        };
        readonly decoding: {
            readonly type: StringConstructor;
            readonly matches: readonly ["sync", "async", "auto"];
        };
        readonly fetchprority: {
            readonly type: StringConstructor;
            readonly matches: readonly ["high", "low", "auto"];
        };
        readonly loading: {
            readonly type: StringConstructor;
            readonly matches: readonly ["eager", "lazy"];
        };
    };
    render: "img";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    attributes: {
        readonly width: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly height: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly referrerpolicy: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin-when-cross-origin", "unsafe-url"];
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: StringConstructor;
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly src: {
            readonly type: typeof SourceAttribute;
            readonly required: true;
            readonly errorLevel: "critical";
            readonly description: "The src of the image you want to see";
        };
        readonly alt: {
            readonly type: StringConstructor;
            readonly required: true;
            readonly errorLevel: "critical";
            readonly description: "The description of the image";
        };
        readonly srcset: {
            readonly type: typeof SrcSetAttribute;
            readonly description: "A set of urls and image sizes that are required to use upload the picture";
            readonly errorLevel: "warning";
        };
        readonly sizes: {
            readonly type: typeof SizesAttribute;
            readonly description: "The size of each image in a media query";
            readonly errorLevel: "warning";
        };
        readonly crossorigin: {
            readonly type: StringConstructor;
            readonly errorLevel: "critical";
            readonly matches: readonly ["anonymous", "use-credentials"];
        };
        readonly decoding: {
            readonly type: StringConstructor;
            readonly matches: readonly ["sync", "async", "auto"];
        };
        readonly fetchprority: {
            readonly type: StringConstructor;
            readonly matches: readonly ["high", "low", "auto"];
        };
        readonly loading: {
            readonly type: StringConstructor;
            readonly matches: readonly ["eager", "lazy"];
        };
    };
    render: "img";
    selfClosing: true;
}>;
declare const video: Readonly<{
    children: readonly ["tag"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly width: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly height: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly autoplay: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
        };
        readonly controls: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
        };
        readonly controlslist: {
            readonly type: StringConstructor;
            readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
            readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
        };
        readonly crossorigin: {
            readonly type: StringConstructor;
            readonly matches: readonly ["anonymous", "use-credentials"];
        };
        readonly loop: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
        };
        readonly muted: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
        };
        readonly preload: {
            readonly type: StringConstructor;
            readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
            readonly matches: readonly ["none", "metadata", "audio"];
        };
        readonly playsinline: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute indicating that the video is to be played 'inline', that is within the element's playback area. Note that the absence of this attribute does not imply that the video will always be played in fullscreen.";
        };
        readonly poster: {
            readonly type: StringConstructor;
            readonly description: "A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.";
        };
    };
    render: "video";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    children: readonly ["tag"];
    attributes: {
        readonly width: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly height: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof IntegerAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly autoplay: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
        };
        readonly controls: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
        };
        readonly controlslist: {
            readonly type: StringConstructor;
            readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
            readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
        };
        readonly crossorigin: {
            readonly type: StringConstructor;
            readonly matches: readonly ["anonymous", "use-credentials"];
        };
        readonly loop: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
        };
        readonly muted: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
        };
        readonly preload: {
            readonly type: StringConstructor;
            readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
            readonly matches: readonly ["none", "metadata", "audio"];
        };
        readonly playsinline: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute indicating that the video is to be played 'inline', that is within the element's playback area. Note that the absence of this attribute does not imply that the video will always be played in fullscreen.";
        };
        readonly poster: {
            readonly type: StringConstructor;
            readonly description: "A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.";
        };
    };
    render: "video";
}>;
declare const audio: Readonly<{
    children: readonly ["tag"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly autoplay: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
        };
        readonly controls: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
        };
        readonly controlslist: {
            readonly type: StringConstructor;
            readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
            readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
        };
        readonly crossorigin: {
            readonly type: StringConstructor;
            readonly matches: readonly ["anonymous", "use-credentials"];
        };
        readonly loop: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
        };
        readonly muted: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
        };
        readonly preload: {
            readonly type: StringConstructor;
            readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
            readonly matches: readonly ["none", "metadata", "audio"];
        };
    };
    render: "audio";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    children: readonly ["tag"];
    attributes: {
        readonly autoplay: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
        };
        readonly controls: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
        };
        readonly controlslist: {
            readonly type: StringConstructor;
            readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
            readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
        };
        readonly crossorigin: {
            readonly type: StringConstructor;
            readonly matches: readonly ["anonymous", "use-credentials"];
        };
        readonly loop: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
        };
        readonly muted: {
            readonly type: BooleanConstructor;
            readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
        };
        readonly preload: {
            readonly type: StringConstructor;
            readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
            readonly matches: readonly ["none", "metadata", "audio"];
        };
    };
    render: "audio";
}>;
declare const ul: Readonly<{
    children: readonly ["tag", "list"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly data: {
            readonly type: ObjectConstructor;
        };
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "ul";
    validate: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
}> | Readonly<{
    children: readonly ["tag", "list"];
    attributes: {
        readonly data: {
            readonly type: ObjectConstructor;
        };
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "ul";
}>;
declare const ol: Readonly<{
    children: readonly ["tag", "list"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly data: {
            readonly type: ObjectConstructor;
        };
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "ol";
    validate: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
}> | Readonly<{
    children: readonly ["tag", "list"];
    attributes: {
        readonly data: {
            readonly type: ObjectConstructor;
        };
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "ol";
}>;
declare const blockquote: Readonly<{
    children: readonly ["fence", "list", "image", "blockquote", "paragraph"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly cite: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof SourceAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "blockquote";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    children: readonly ["fence", "list", "image", "blockquote", "paragraph"];
    attributes: {
        readonly cite: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: typeof SourceAttribute;
            required: true | undefined;
            errorLevel: "warning";
        }>;
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "blockquote";
}>;
declare const details: Readonly<{
    children: readonly ["tag", "paragraph", "blockquote", "fence", "image", "list"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly data: {
            readonly type: ObjectConstructor;
        };
        readonly open: {
            readonly type: BooleanConstructor;
        };
    };
    render: "details";
    validate: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
}> | Readonly<{
    children: readonly ["tag", "paragraph", "blockquote", "fence", "image", "list"];
    attributes: {
        readonly data: {
            readonly type: ObjectConstructor;
        };
        readonly open: {
            readonly type: BooleanConstructor;
        };
    };
    render: "details";
}>;
declare const picture: Readonly<{
    children: readonly ["tag"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "picture";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    children: readonly ["tag"];
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "picture";
}>;
declare const dl: Readonly<{
    children: readonly ["tag"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "dl";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    children: readonly ["tag"];
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "dl";
}>;
declare const colgroup: Readonly<{
    children: readonly ["tag"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly style: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly span: {
            readonly type: typeof IntegerAttribute;
        };
    };
    render: "colgroup";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    children: readonly ["tag"];
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly style: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly span: {
            readonly type: typeof IntegerAttribute;
        };
    };
    render: "colgroup";
}>;
declare const col: Readonly<{
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly style: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly span: {
            readonly type: typeof IntegerAttribute;
        };
    };
    render: "col";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly style: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                    returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly span: {
            readonly type: typeof IntegerAttribute;
        };
    };
    render: "col";
    selfClosing: true;
}>;
declare const p: Readonly<{
    children: readonly ["text", "paragraph", "link", "softbreak"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly draggable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "p";
}> | Readonly<{
    children: readonly ["text", "paragraph", "link", "softbreak"];
    attributes: {
        readonly contenteditable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly draggable: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly title: Readonly<{
            description: string;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: {
                new (): {
                    returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location: _markdoc_markdoc.Location;
                    } | {
                        id: string;
                        level: "error" | "debug" | "info" | "warning" | "critical";
                        message: string;
                        location?: undefined;
                    }> | undefined;
                    validate(value: unknown, config: Readonly<Partial<{
                        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                        variables: Record<string, any>;
                        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                        partials: Record<string, any>;
                        validation?: {
                            validateFunctions?: boolean | undefined;
                        } | undefined;
                    }>>): _markdoc_markdoc.ValidationError[];
                };
            };
            required: true | undefined;
            errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
        }>;
        readonly lang: Readonly<{
            description: string;
            matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
        readonly dir: Readonly<{
            description: string;
            matches: readonly ["auto", "ltr", "rtl"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
    };
    render: "p";
}>;
declare const wbr: Readonly<{
    description: "A schema for creating a wbr element";
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "wbr";
    slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
    selfClosing: true;
    validate: ((node: Node, config: Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
}> | Readonly<{
    description: "A schema for creating a wbr element";
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
    };
    render: "wbr";
    selfClosing: true;
}>;
declare const cite: Readonly<{
    description: "A schema for creating a cite element";
    children: readonly ["tag", "text", "link", "em", "strong"];
    transform: (node: Node, config: Readonly<Partial<{
        nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
        tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
        variables: Record<string, any>;
        functions: Record<string, _markdoc_markdoc.ConfigFunction>;
        partials: Record<string, any>;
        validation?: {
            validateFunctions?: boolean | undefined;
        } | undefined;
    }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
    };
    render: "cite";
    validate: (node: Node) => _markdoc_markdoc.ValidationError[];
}> | Readonly<{
    description: "A schema for creating a cite element";
    children: readonly ["tag", "text", "link", "em", "strong"];
    attributes: {
        readonly hidden: Readonly<{
            description: string | undefined;
            render: string | boolean | undefined;
            matches: RegExp | readonly string[] | readonly number[] | undefined;
            default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
            type: BooleanConstructor;
            required: true | undefined;
            errorLevel: "error";
        }>;
        readonly translate: Readonly<{
            description: string;
            matches: readonly ["yes", "no"];
            type: StringConstructor;
            errorLevel: "error";
        }>;
        readonly spellcheck: Readonly<{
            description: string;
            type: BooleanConstructor;
            errorLevel: "error";
        }>;
    };
    render: "cite";
}>;

declare const markdocHTMLTagSchemas: (options?: Partial<{
    blankDoc: false;
    strictHeadings: true;
}>) => {
    nodes: {
        document: {
            render: string | null;
            children?: string[] | undefined;
            attributes?: Record<string, _markdoc_markdoc.SchemaAttribute> | undefined;
            slots?: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing?: boolean | undefined;
            inline?: boolean | undefined;
            transform?(node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>): _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            validate?(node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>): _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
            description?: string | undefined;
        };
        heading: {
            attributes: {
                level: {
                    type: NumberConstructor;
                    required: boolean;
                    matches: number[];
                };
            };
            render?: string | undefined;
            children?: string[] | undefined;
            slots?: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing?: boolean | undefined;
            inline?: boolean | undefined;
            transform?(node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>): _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            validate?(node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>): _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
            description?: string | undefined;
        };
        image: {
            render: "img";
            attributes: {
                src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly errorLevel: "critical";
                    readonly description: "The src of the image you want to see";
                };
                title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                alt: {
                    readonly type: StringConstructor;
                    readonly required: true;
                    readonly errorLevel: "critical";
                    readonly description: "The description of the image";
                };
            };
        };
        link: {
            render: "a";
            attributes: {
                href: {
                    readonly type: typeof HrefAttribute;
                    readonly required: true;
                };
                title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
            };
        };
    };
    tags: {
        iframe: Readonly<{
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly description: "This attribute is the path to the place containing media to display";
                };
                readonly allow: {
                    readonly type: typeof AllowAttribute;
                    readonly description: "An attribute that makes sure that the user creates an object.\n            The allowed allowedPermissionDirectives as keys.\n            The values for them as values.\n            ";
                };
                readonly name: {
                    readonly type: StringConstructor;
                    readonly description: "The name of the iframe";
                };
                readonly loading: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["eager", "lazy"];
                };
                readonly sandbox: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["allow-downloads", "allow-forms", "allow-modals", "allow-orientation-lock", "allow-pointer-lock", "allow-popups", "allow-popups-to-escape-sandbox", "allow-same-origin", "allow-scripts", "allow-top-navigation", "allow-top-navigation-by-user-activation", "allow-top-navigation-to-custom-protocols"];
                };
                readonly width: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly height: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            render: "iframe";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            attributes: {
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly description: "This attribute is the path to the place containing media to display";
                };
                readonly allow: {
                    readonly type: typeof AllowAttribute;
                    readonly description: "An attribute that makes sure that the user creates an object.\n            The allowed allowedPermissionDirectives as keys.\n            The values for them as values.\n            ";
                };
                readonly name: {
                    readonly type: StringConstructor;
                    readonly description: "The name of the iframe";
                };
                readonly loading: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["eager", "lazy"];
                };
                readonly sandbox: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["allow-downloads", "allow-forms", "allow-modals", "allow-orientation-lock", "allow-pointer-lock", "allow-popups", "allow-popups-to-escape-sandbox", "allow-same-origin", "allow-scripts", "allow-top-navigation", "allow-top-navigation-by-user-activation", "allow-top-navigation-to-custom-protocols"];
                };
                readonly width: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly height: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            render: "iframe";
            selfClosing: true;
        }>;
        source: Readonly<{
            description: "This is the schema for the HTML source tag";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly description: "A set of urls and image sizes that are required to use upload the picture";
                };
                readonly srcset: {
                    readonly type: typeof SrcSetAttribute;
                    readonly description: "A set of urls and image sizes that are required to use upload the picture";
                };
                readonly sizes: {
                    readonly type: typeof SizesAttribute;
                    readonly description: "The size of each image in a media query";
                    readonly errorLevel: "warning";
                };
                readonly media: {
                    readonly type: typeof MediaAttribute;
                    readonly description: "The art resolution or time for an image to appear in a media query";
                    readonly errorLevel: "warning";
                };
                readonly type: {
                    readonly type: StringConstructor;
                    readonly errorLevel: "warning";
                    readonly description: "The type of image that is being used";
                };
            };
            render: "source";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            description: "This is the schema for the HTML source tag";
            attributes: {
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly description: "A set of urls and image sizes that are required to use upload the picture";
                };
                readonly srcset: {
                    readonly type: typeof SrcSetAttribute;
                    readonly description: "A set of urls and image sizes that are required to use upload the picture";
                };
                readonly sizes: {
                    readonly type: typeof SizesAttribute;
                    readonly description: "The size of each image in a media query";
                    readonly errorLevel: "warning";
                };
                readonly media: {
                    readonly type: typeof MediaAttribute;
                    readonly description: "The art resolution or time for an image to appear in a media query";
                    readonly errorLevel: "warning";
                };
                readonly type: {
                    readonly type: StringConstructor;
                    readonly errorLevel: "warning";
                    readonly description: "The type of image that is being used";
                };
            };
            render: "source";
            selfClosing: true;
        }>;
        track: Readonly<{
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly description: "The url where the file is placed";
                };
                readonly default: {
                    readonly type: BooleanConstructor;
                };
                readonly label: {
                    readonly type: StringConstructor;
                };
                readonly srclang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly kind: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["captions", "chapters", "descriptions", "metadata", "subtitles"];
                };
            };
            render: "track";
            selfClosing: true;
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            attributes: {
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly description: "The url where the file is placed";
                };
                readonly default: {
                    readonly type: BooleanConstructor;
                };
                readonly label: {
                    readonly type: StringConstructor;
                };
                readonly srclang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly kind: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["captions", "chapters", "descriptions", "metadata", "subtitles"];
                };
            };
            render: "track";
            selfClosing: true;
        }>;
        hr: Readonly<{
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "hr";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "hr";
            selfClosing: true;
        }>;
        br: Readonly<{
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "br";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "br";
            selfClosing: true;
        }>;
        video: Readonly<{
            children: readonly ["tag"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly width: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly height: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly autoplay: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
                };
                readonly controls: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
                };
                readonly controlslist: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
                    readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
                };
                readonly crossorigin: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["anonymous", "use-credentials"];
                };
                readonly loop: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
                };
                readonly muted: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
                };
                readonly preload: {
                    readonly type: StringConstructor;
                    readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
                    readonly matches: readonly ["none", "metadata", "audio"];
                };
                readonly playsinline: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute indicating that the video is to be played 'inline', that is within the element's playback area. Note that the absence of this attribute does not imply that the video will always be played in fullscreen.";
                };
                readonly poster: {
                    readonly type: StringConstructor;
                    readonly description: "A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.";
                };
            };
            render: "video";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["tag"];
            attributes: {
                readonly width: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly height: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly autoplay: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
                };
                readonly controls: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
                };
                readonly controlslist: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
                    readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
                };
                readonly crossorigin: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["anonymous", "use-credentials"];
                };
                readonly loop: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
                };
                readonly muted: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
                };
                readonly preload: {
                    readonly type: StringConstructor;
                    readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
                    readonly matches: readonly ["none", "metadata", "audio"];
                };
                readonly playsinline: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute indicating that the video is to be played 'inline', that is within the element's playback area. Note that the absence of this attribute does not imply that the video will always be played in fullscreen.";
                };
                readonly poster: {
                    readonly type: StringConstructor;
                    readonly description: "A URL for an image to be shown while the video is downloading. If this attribute isn't specified, nothing is displayed until the first frame is available, then the first frame is shown as the poster frame.";
                };
            };
            render: "video";
        }>;
        audio: Readonly<{
            children: readonly ["tag"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly autoplay: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
                };
                readonly controls: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
                };
                readonly controlslist: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
                    readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
                };
                readonly crossorigin: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["anonymous", "use-credentials"];
                };
                readonly loop: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
                };
                readonly muted: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
                };
                readonly preload: {
                    readonly type: StringConstructor;
                    readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
                    readonly matches: readonly ["none", "metadata", "audio"];
                };
            };
            render: "audio";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["tag"];
            attributes: {
                readonly autoplay: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio will automatically begin playback as soon as it can do so";
                };
                readonly controls: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the user can control the audio of the ";
                };
                readonly controlslist: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["nodownload", "nofullscreen", "noremoteplayback"];
                    readonly description: "A String attribute: if specified, helps the browser select what controls to show for the audio element whenever the browser shows its own set of controls (that is, when the controls attribute is specified).";
                };
                readonly crossorigin: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["anonymous", "use-credentials"];
                };
                readonly loop: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute: if specified, the audio player will automatically seek back to the start upon reaching the end of the audio.";
                };
                readonly muted: {
                    readonly type: BooleanConstructor;
                    readonly description: "A Boolean attribute that indicates whether the audio will be initially silenced.Its default value is false.";
                };
                readonly preload: {
                    readonly type: StringConstructor;
                    readonly description: "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience.";
                    readonly matches: readonly ["none", "metadata", "audio"];
                };
            };
            render: "audio";
        }>;
        ol: Readonly<{
            children: readonly ["tag", "list"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly data: {
                    readonly type: ObjectConstructor;
                };
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "ol";
            validate: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
        }> | Readonly<{
            children: readonly ["tag", "list"];
            attributes: {
                readonly data: {
                    readonly type: ObjectConstructor;
                };
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "ol";
        }>;
        blockquote: Readonly<{
            children: readonly ["fence", "list", "image", "blockquote", "paragraph"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly cite: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof SourceAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "blockquote";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["fence", "list", "image", "blockquote", "paragraph"];
            attributes: {
                readonly cite: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof SourceAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "blockquote";
        }>;
        details: Readonly<{
            children: readonly ["tag", "paragraph", "blockquote", "fence", "image", "list"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly data: {
                    readonly type: ObjectConstructor;
                };
                readonly open: {
                    readonly type: BooleanConstructor;
                };
            };
            render: "details";
            validate: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
        }> | Readonly<{
            children: readonly ["tag", "paragraph", "blockquote", "fence", "image", "list"];
            attributes: {
                readonly data: {
                    readonly type: ObjectConstructor;
                };
                readonly open: {
                    readonly type: BooleanConstructor;
                };
            };
            render: "details";
        }>;
        picture: Readonly<{
            children: readonly ["tag"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "picture";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["tag"];
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "picture";
        }>;
        dl: Readonly<{
            children: readonly ["tag"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "dl";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["tag"];
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "dl";
        }>;
        colgroup: Readonly<{
            children: readonly ["tag"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly style: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly span: {
                    readonly type: typeof IntegerAttribute;
                };
            };
            render: "colgroup";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["tag"];
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly style: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly span: {
                    readonly type: typeof IntegerAttribute;
                };
            };
            render: "colgroup";
        }>;
        col: Readonly<{
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly style: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly span: {
                    readonly type: typeof IntegerAttribute;
                };
            };
            render: "col";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly style: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            transform(value: Record<string, string | number>): _markdoc_markdoc.Scalar;
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly span: {
                    readonly type: typeof IntegerAttribute;
                };
            };
            render: "col";
            selfClosing: true;
        }>;
        p: Readonly<{
            children: readonly ["text", "paragraph", "link", "softbreak"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly draggable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "p";
        }> | Readonly<{
            children: readonly ["text", "paragraph", "link", "softbreak"];
            attributes: {
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly draggable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "p";
        }>;
        wbr: Readonly<{
            description: "A schema for creating a wbr element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "wbr";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            description: "A schema for creating a wbr element";
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
            };
            render: "wbr";
            selfClosing: true;
        }>;
        cite: Readonly<{
            description: "A schema for creating a cite element";
            children: readonly ["tag", "text", "link", "em", "strong"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "cite";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            description: "A schema for creating a cite element";
            children: readonly ["tag", "text", "link", "em", "strong"];
            attributes: {
                readonly hidden: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: BooleanConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "cite";
        }>;
        abbr: Readonly<{
            description: "A tag that automatically creates an abbreviation of a capitalised word";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
                readonly title: {
                    readonly type: StringConstructor;
                    readonly errorLevel: "error";
                    readonly matches: RegExp;
                };
            };
            render: "abbr";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "abbr";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
                readonly title: {
                    readonly type: StringConstructor;
                    readonly errorLevel: "error";
                    readonly matches: RegExp;
                };
            };
            readonly description: "A tag that automatically creates an abbreviation of a capitalised word";
        } & {
            selfClosing: true;
        }>;
        sup: Readonly<{
            description: "A schema for creating a sup element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "sup";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "sup";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a sup element";
        } & {
            selfClosing: true;
        }>;
        li: Readonly<{
            inline: false;
            description: "A schema for creating a sup element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "li";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "li";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a sup element";
            readonly inline: false;
        } & {
            selfClosing: true;
        }>;
        small: Readonly<{
            description: "A schema for creating a sup element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "small";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "small";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a sup element";
        } & {
            selfClosing: true;
        }>;
        del: Readonly<{
            description: "A schema for creating a del element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
                readonly cite: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof SourceAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly datetime: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            render: "del";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "del";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
                readonly cite: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof SourceAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly datetime: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            readonly description: "A schema for creating a del element";
        } & {
            selfClosing: true;
        }>;
        ins: Readonly<{
            description: "A schema for creating a ins element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
                readonly cite: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof SourceAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly datetime: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            render: "ins";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "ins";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
                readonly cite: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof SourceAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly datetime: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            readonly description: "A schema for creating a ins element";
        } & {
            selfClosing: true;
        }>;
        sub: Readonly<{
            description: "A schema for creating a sub element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "sub";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "sub";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a sub element";
        } & {
            selfClosing: true;
        }>;
        code: Readonly<{
            description: "A schema for creating a code element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "code";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "code";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a code element";
        } & {
            selfClosing: true;
        }>;
        samp: Readonly<{
            description: "A schema for creating a samp element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "samp";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "samp";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a samp element";
        } & {
            selfClosing: true;
        }>;
        mark: Readonly<{
            description: "A schema for creating a mark element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "mark";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "mark";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a mark element";
        } & {
            selfClosing: true;
        }>;
        q: Readonly<{
            description: "A schema for creating a q element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "q";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "q";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a q element";
        } & {
            selfClosing: true;
        }>;
        kbd: Readonly<{
            description: "A schema for creating a kbd element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "kbd";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "kbd";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a kbd element";
        } & {
            selfClosing: true;
        }>;
        bdo: Readonly<{
            description: "A schema for creating a bdo element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "bdo";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "bdo";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a bdo element";
        } & {
            selfClosing: true;
        }>;
        bdi: Readonly<{
            description: "A schema for creating a bdi element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "bdi";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "bdi";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a bdi element";
        } & {
            selfClosing: true;
        }>;
        data: Readonly<{
            description: "A schema for creating a data element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "data";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "data";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a data element";
        } & {
            selfClosing: true;
        }>;
        dd: Readonly<{
            inline: false;
            description: "A schema for creating a dd element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "dd";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "dd";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly inline: false;
            readonly description: "A schema for creating a dd element";
        } & {
            selfClosing: true;
        }>;
        dt: Readonly<{
            inline: false;
            description: "A schema for creating a dt element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "dt";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "dt";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly inline: false;
            readonly description: "A schema for creating a dt element";
        } & {
            selfClosing: true;
        }>;
        span: Readonly<{
            description: "A schema for creating a span element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "span";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "span";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a span element";
        } & {
            selfClosing: true;
        }>;
        time: Readonly<{
            inline: false;
            description: "A schema for creating a time element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                };
                readonly datetime: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            render: "time";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "time";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                };
                readonly datetime: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): void | _markdoc_markdoc.ValidationError;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
            };
            readonly description: "A schema for creating a time element";
            readonly inline: false;
        } & {
            selfClosing: true;
        }>;
        summary: Readonly<{
            inline: false;
            description: "This is the summary for the details tag";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "summary";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "summary";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "This is the summary for the details tag";
            readonly inline: false;
        } & {
            selfClosing: true;
        }>;
        dfn: Readonly<{
            inline: false;
            description: "A schema for creating a dfn element";
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes> | undefined;
            attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            render: "dfn";
            selfClosing: true;
        }> | Readonly<{
            readonly render: "dfn";
            readonly attributes: {
                readonly primary: {
                    readonly required: true;
                    readonly render: true;
                    readonly type: StringConstructor;
                };
            };
            readonly description: "A schema for creating a dfn element";
            readonly inline: false;
        } & {
            selfClosing: true;
        }>;
        img: Readonly<{
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly width: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly height: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly referrerpolicy: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin-when-cross-origin", "unsafe-url"];
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: StringConstructor;
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly errorLevel: "critical";
                    readonly description: "The src of the image you want to see";
                };
                readonly alt: {
                    readonly type: StringConstructor;
                    readonly required: true;
                    readonly errorLevel: "critical";
                    readonly description: "The description of the image";
                };
                readonly srcset: {
                    readonly type: typeof SrcSetAttribute;
                    readonly description: "A set of urls and image sizes that are required to use upload the picture";
                    readonly errorLevel: "warning";
                };
                readonly sizes: {
                    readonly type: typeof SizesAttribute;
                    readonly description: "The size of each image in a media query";
                    readonly errorLevel: "warning";
                };
                readonly crossorigin: {
                    readonly type: StringConstructor;
                    readonly errorLevel: "critical";
                    readonly matches: readonly ["anonymous", "use-credentials"];
                };
                readonly decoding: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["sync", "async", "auto"];
                };
                readonly fetchprority: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["high", "low", "auto"];
                };
                readonly loading: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["eager", "lazy"];
                };
            };
            render: "img";
            slots: Record<string, _markdoc_markdoc.SchemaSlot> | undefined;
            selfClosing: true;
            validate: ((node: _markdoc_markdoc.Node, config: Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>) | undefined;
        }> | Readonly<{
            attributes: {
                readonly width: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly height: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: typeof IntegerAttribute;
                    required: true | undefined;
                    errorLevel: "warning";
                }>;
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly referrerpolicy: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin-when-cross-origin", "unsafe-url"];
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: StringConstructor;
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly src: {
                    readonly type: typeof SourceAttribute;
                    readonly required: true;
                    readonly errorLevel: "critical";
                    readonly description: "The src of the image you want to see";
                };
                readonly alt: {
                    readonly type: StringConstructor;
                    readonly required: true;
                    readonly errorLevel: "critical";
                    readonly description: "The description of the image";
                };
                readonly srcset: {
                    readonly type: typeof SrcSetAttribute;
                    readonly description: "A set of urls and image sizes that are required to use upload the picture";
                    readonly errorLevel: "warning";
                };
                readonly sizes: {
                    readonly type: typeof SizesAttribute;
                    readonly description: "The size of each image in a media query";
                    readonly errorLevel: "warning";
                };
                readonly crossorigin: {
                    readonly type: StringConstructor;
                    readonly errorLevel: "critical";
                    readonly matches: readonly ["anonymous", "use-credentials"];
                };
                readonly decoding: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["sync", "async", "auto"];
                };
                readonly fetchprority: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["high", "low", "auto"];
                };
                readonly loading: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["eager", "lazy"];
                };
            };
            render: "img";
            selfClosing: true;
        }>;
        a: Readonly<{
            children: readonly ["tag", "text", "strong", "em", "image", "paragraph"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly href: {
                    readonly type: typeof HrefAttribute;
                    readonly required: true;
                };
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly target: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: readonly ["_target", "_blank", "_parent", "_top"];
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: StringConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly type: {
                    readonly type: StringConstructor;
                    readonly matches: RegExp;
                };
                readonly rel: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["alternate", "author", "bookmark", "external", "help", "license", "next", "nofollow", "noreferrer", "noopener", "prev", "search", "tag"];
                };
                readonly reffererpolicy: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin", "strict-origin-when-cross-origin", "unsafe-url"];
                };
                readonly download: {
                    readonly type: typeof DownloadAttribute;
                    readonly errorLevel: "error";
                    readonly description: "Allows the user to download a file from the computer or the project file system";
                };
            };
            render: "a";
            validate: (node: _markdoc_markdoc.Node) => _markdoc_markdoc.ValidationError[];
        }> | Readonly<{
            children: readonly ["tag", "text", "strong", "em", "image", "paragraph"];
            attributes: {
                readonly href: {
                    readonly type: typeof HrefAttribute;
                    readonly required: true;
                };
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly target: Readonly<{
                    description: string | undefined;
                    render: string | boolean | undefined;
                    matches: readonly ["_target", "_blank", "_parent", "_top"];
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: StringConstructor;
                    required: true | undefined;
                    errorLevel: "error";
                }>;
                readonly type: {
                    readonly type: StringConstructor;
                    readonly matches: RegExp;
                };
                readonly rel: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["alternate", "author", "bookmark", "external", "help", "license", "next", "nofollow", "noreferrer", "noopener", "prev", "search", "tag"];
                };
                readonly reffererpolicy: {
                    readonly type: StringConstructor;
                    readonly matches: readonly ["no-referrer", "no-referrer-when-downgrade", "origin", "origin-when-cross-origin", "same-origin", "strict-origin", "strict-origin-when-cross-origin", "unsafe-url"];
                };
                readonly download: {
                    readonly type: typeof DownloadAttribute;
                    readonly errorLevel: "error";
                    readonly description: "Allows the user to download a file from the computer or the project file system";
                };
            };
            render: "a";
        }>;
        ul: Readonly<{
            children: readonly ["tag", "list"];
            transform: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.RenderableTreeNodes>;
            attributes: {
                readonly data: {
                    readonly type: ObjectConstructor;
                };
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "ul";
            validate: (node: _markdoc_markdoc.Node, config: Readonly<Partial<{
                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                variables: Record<string, any>;
                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                partials: Record<string, any>;
                validation?: {
                    validateFunctions?: boolean | undefined;
                } | undefined;
            }>>) => _markdoc_markdoc.MaybePromise<_markdoc_markdoc.ValidationError[]>;
        }> | Readonly<{
            children: readonly ["tag", "list"];
            attributes: {
                readonly data: {
                    readonly type: ObjectConstructor;
                };
                readonly title: Readonly<{
                    description: string;
                    render: string | boolean | undefined;
                    matches: RegExp | readonly string[] | readonly number[] | undefined;
                    default: string | number | Record<string, _markdoc_markdoc.Scalar> | undefined;
                    type: {
                        new (): {
                            returnMarkdocErrorObjectOrNothing(value: unknown): Readonly<{
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location: _markdoc_markdoc.Location;
                            } | {
                                id: string;
                                level: "error" | "debug" | "info" | "warning" | "critical";
                                message: string;
                                location?: undefined;
                            }> | undefined;
                            validate(value: unknown, config: Readonly<Partial<{
                                nodes: Partial<Record<_markdoc_markdoc.NodeType, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>>;
                                tags: Record<string, _markdoc_markdoc.Schema<Readonly<Partial<any>>, string>>;
                                variables: Record<string, any>;
                                functions: Record<string, _markdoc_markdoc.ConfigFunction>;
                                partials: Record<string, any>;
                                validation?: {
                                    validateFunctions?: boolean | undefined;
                                } | undefined;
                            }>>): _markdoc_markdoc.ValidationError[];
                        };
                    };
                    required: true | undefined;
                    errorLevel: "error" | "debug" | "info" | "warning" | "critical" | undefined;
                }>;
                readonly spellcheck: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly lang: Readonly<{
                    description: string;
                    matches: readonly ["aa", "ab", "ace", "ach", "ada", "ady", "ae", "aeb", "af", "afh", "agq", "ain", "ak", "akk", "akz", "ale", "aln", "alt", "am", "an", "ang", "anp", "ar", "ar-001", "arc", "arn", "aro", "arp", "arq", "arw", "ary", "arz", "as", "asa", "ase", "ast", "av", "avk", "awa", "ay", "az", "az-Arab", "ba", "bal", "ban", "bar", "bas", "bax", "bbc", "bbj", "be", "bej", "bem", "bew", "bez", "bfd", "bfq", "bg", "bgn", "bho", "bi", "bik", "bin", "bjn", "bkm", "bla", "bm", "bn", "bo", "bpy", "bqi", "br", "bra", "brh", "brx", "bs", "bss", "bua", "bug", "bum", "byn", "byv", "ca", "cad", "car", "cay", "cch", "ccp", "ce", "ceb", "cgg", "ch", "chb", "chg", "chk", "chm", "chn", "cho", "chp", "chr", "chy", "ckb", "co", "cop", "cps", "cr", "crh", "crs", "cs", "csb", "cu", "cv", "cy", "da", "dak", "dar", "dav", "de", "del", "den", "dgr", "din", "dje", "doi", "dsb", "dtp", "dua", "dum", "dv", "dyo", "dyu", "dz", "dzg", "ebu", "ee", "efi", "egl", "egy", "eka", "el", "elx", "en", "en-AU", "en-CA", "en-GB", "en-US", "enm", "eo", "es", "es-419", "es-AR", "es-CL", "es-CO", "es-CR", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "et", "eu", "ewo", "ext", "fa", "fa-AF", "ff", "ff-Adlm", "ff-Latn", "fi", "fil", "fit", "fj", "fo", "fon", "fr", "fr-CA", "fr-CH", "frc", "frm", "fro", "frp", "frr", "frs", "fur", "fy", "ga", "gaa", "gag", "gan", "gay", "gba", "gbz", "gd", "gez", "gil", "gl", "glk", "gmh"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly contenteditable: Readonly<{
                    description: string;
                    type: BooleanConstructor;
                    errorLevel: "error";
                }>;
                readonly translate: Readonly<{
                    description: string;
                    matches: readonly ["yes", "no"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
                readonly dir: Readonly<{
                    description: string;
                    matches: readonly ["auto", "ltr", "rtl"];
                    type: StringConstructor;
                    errorLevel: "error";
                }>;
            };
            render: "ul";
        }>;
    };
};

export { type MarkdocAttributeSchema, MarkdocAttributes, type PrimaryMarkdocAttributeSchema, type RequiredSchemaAttribute, type SchemaAttributesWithAPrimaryKey, type SchemaAttributesWithNoPrimaryKey, a, abbr, audio, bdi, bdo, blockquote, br, cite, code, col, colgroup, data, dd, del, details, dfn, dl, dt, hr, iframe, img, ins, kbd, li, mark, markdocHTMLTagSchemas, ol, p, picture, q, samp, small, source, span, sub, summary, sup, time, track, ul, video, wbr };
