var u=class{constructor(t,n,o){this.firstIterationNum=t;this.iterationNum=n;this.lastIterationNum=o}get count(){return this.lastIterationNum-this.firstIterationNum}get iteration(){return this.iterationNum+1}get isFirst(){return this.firstIterationNum===this.iterationNum}get isLast(){return this.lastIterationNum===this.iteration}get isEven(){return this.iterationNum%2===0}get isOdd(){return this.iterationNum%2!==0}get remaining(){return this.lastIterationNum-this.iteration}};function*E(e){let n=new Map,o=0;e.forEach((r,a)=>n.set(a,r));let s=n.size;for(let[r,a]of n)yield{value:a,info:new u(0,o,s),key:r},o++}var p=e=>c(e)&&(typeof e[Symbol.iterator]=="function"||typeof e[Symbol.asyncIterator]=="function");function c(e){return typeof e=="object"&&e!=null}function g(e){return p(e)&&e.toString()==="[object Generator]"}function d(e){return async function*(...t){let n=e(...t);if(n instanceof Promise){yield await n;return}yield n}}function I(e){return c(e)&&"forEach"in e}function F(e,t){if(e)return t()}function m(e,t,n){function o(s){let r=["ifCb","elseCb","condition"];return c(s)&&r.length===Object.keys(s).length&&r.every(a=>a in s)}if(o(e)&&!t&&!n){let{condition:s,ifCb:r,elseCb:a}=e;return s?r():a()}return e?t?.():n?.()}function B(e,t){return F(!e,t)}function T(e,t="Condition is false"){F(e,()=>{throw new Error(t)})}function l(e,t="Condition is true"){T(!e,t)}var Y=e=>({transform(t){return e(...Object.values(t))}});function*O(e,t,n={}){let{step:o=1,inclusive:s}=n;if(T(e===t,"Start can't be the same as stop"),T(o<=0,"Step can't be zero or a negative number"),e>t){let r=e;if(s){for(;r>=t;)yield r,r-=o;return}for(;r>t;)yield r,r-=o;return}if(e<t){let r=e;if(s){for(;r<=t;)yield r,r+=o;return}for(;r<t;)yield r,r+=o}}async function*w(e,t){if(l(p(e),"You did not pass in an iterable"),I(e)){for(let{value:n,info:o,key:s}of E(e))yield*d(t)(n,o,s);return}if(g(e))for(let n of e)yield*d(t)(n)}function*$(e,t){if(l(p(e),"You did not pass in an iterable"),I(e)){for(let{value:n,info:o,key:s}of E(e))yield t(n,o,s);return}if(g(e))for(let n of e)yield t(n)}async function*_(e,t){let{start:n,stop:o,step:s=1,inclusive:r}=t;yield*w(O(n,o,{step:s,inclusive:r}),a=>e(a,new u(n,a,o)))}var b=e=>Object.assign((t,n,o)=>({...t,[Symbol.toStringTag]:"AstroComponent",async*[Symbol.asyncIterator](){yield*d(e)(n,o)}}),{isAstroComponentFactory:!0});async function J(e){try{return[await e,null]}catch(t){return t instanceof Error?[null,t]:typeof t=="string"?[null,new Error(t)]:typeof t=="object"?[null,new Error(JSON.stringify(t,null,2))]:[null,new Error("Something went wrong")]}}var A=0,P=e=>{let t,n;A++;let o=b((r,a)=>{l(typeof a.default=="function",`Please pass a Child into this component
            Templater${e?.toUpperCase()??A} Invalid Child`),t=a.default;let f=c(r)&&Object.keys(r).length>0;f&&(n=Object.freeze(r))}),s=b((r,a)=>{let i=t?.()?.expressions.at(0),y=c(r)&&Object.keys(r).length>0;return m(typeof i=="function",()=>m(y,()=>i(Object.freeze(r),m(n,()=>()=>a?.default(n),()=>a?.default)),()=>i(a.default)),t)});return[o,s]};import{getCollection as h,getEntryBySlug as D,getEntry as N,getEntries as G}from"astro:content";var ot=async(e,t)=>t?(await Promise.all(e.map(n=>h(n,t)))).flat():(await Promise.all(e.map(n=>h(n)))).flat(),C=async(e,t)=>(await h(e,t)).map(n=>({slug:n.slug,...n.data})),k=async(e,t)=>await C(e,x(t)),U=async(e,t)=>await C(e,S(t)),at=Object.assign(C,{filterNonDrafts:k,filterDrafts:U}),R=async(e,t)=>{let n=await N(e,t);return"slug"in n?{slug:n.slug,...n.data}:n.data},M=async(e,t)=>{let n=await D(e,t);return{slug:n.slug,...n.data}},st=Object.assign(R,{bySlug:M}),it=async e=>(await G(e)).map(t=>({slug:t.slug,...t.data})),lt=async(e,t,n)=>{let o=new Map,s=await h(e,x(n)),r=["render","body"];return s.map((a,f)=>{if(f!==0&&o.clear(),typeof t=="string"){if(r.includes(t))throw new Error(`Don't use these ${r.join(" ")} keys at all if you do the values from the entry will be used it will not come from the data.`);let i=t in a?a[t]:t in a.data?a.data[t]:null;l(typeof i=="string"||typeof i=="number","You can only use strings and numbers as params"),o.set(t,i)}return Array.isArray(t)&&t.forEach(i=>{if(typeof i=="string"&&r.includes(i))throw new Error(`Don't use these ${r.join(" ")} keys at all if you do the values from the entry will be used it will not come from the data.`);let y=i in a?a[i]:i in a.data?a.data[i]:null;l(typeof y=="string"||typeof y=="number","You can only use strings and numbers as params"),o.set(i,y)}),{params:Object.fromEntries(o),props:a}})};function S(e){return function(t){return"draft"in t.data||"draft"in t.data&&t.data.draft===!0||!!e?.(t)}}function x(e){return function(t){return!("draft"in t.data)||"draft"in t.data&&!t.data.draft||!!e?.(t)}}export{u as IterationInfo,b as createAstroFunctionalComponent,Y as createMarkdocFunction,F as executeIf,m as executeIfElse,B as executeUnless,at as getCollectionDataList,lt as getCollectionPaths,ot as getCollections,it as getDataListFromEntries,st as getEntryData,w as iterate,_ as iterateRange,O as range,J as returnErrorAndResultFromPromise,$ as syncIterate,T as throwIf,l as throwUnless,P as useTemplaterAndProjector};
//! Never return fom this function!
