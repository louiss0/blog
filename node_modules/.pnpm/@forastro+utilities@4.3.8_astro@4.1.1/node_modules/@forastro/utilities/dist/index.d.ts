import { CollectionKey, CollectionEntry, getEntryBySlug, getEntry, getEntries } from 'astro:content';
import * as node_modules_astro_dist_core_cookies_cookies from 'node_modules/astro/dist/core/cookies/cookies';
import * as astro_runtime_server_index_js from 'astro/runtime/server/index.js';
import * as astro from 'astro';
import { SSRResult, Props } from 'astro';

type RenderTemplateResult$1 = {
    htmlParts: Array<string>
    expressions: Array<unknown>
    error?: Error
}

type StringKeyedObjectLiteralWithUnknownValues = Record<string, unknown>

type ReturnUndefinedIfTypeIsNotAStringKeyedObjectLiteralWithUnknownValues<T> =
    T extends StringKeyedObjectLiteralWithUnknownValues
    ? T
    : undefined


type ProjectorSlot = (() => RenderTemplateResult$1) | undefined


type TemplaterProps<
    ProjectorProps extends StringKeyedObjectLiteralWithUnknownValues | null,
    TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues | null,
> =
    ReturnUndefinedIfTypeIsNotAStringKeyedObjectLiteralWithUnknownValues<ProjectorProps> extends StringKeyedObjectLiteralWithUnknownValues
    ? TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues
    ? TemplaterProps & {
        children: (context: Readonly<ProjectorProps>, slots: ProjectorSlot) => unknown
    } : {
        children: (context: Readonly<ProjectorProps>, slots: ProjectorSlot) => unknown
    }
    : TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues
    ? TemplaterProps & {

        children: ((defaultSlot: ProjectorSlot) => unknown)
        | Array<astroHTML.JSX.HTMLAttributes>
        | string;
    }
    : {
        children: ((defaultSlot: ProjectorSlot) => unknown)
        | Array<astroHTML.JSX.HTMLAttributes>
        | string;
    }






type ProjectorProps<
    TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues | null,
    ProjectorProps extends StringKeyedObjectLiteralWithUnknownValues | null,
> =
    ReturnUndefinedIfTypeIsNotAStringKeyedObjectLiteralWithUnknownValues<
        ProjectorProps
    > extends StringKeyedObjectLiteralWithUnknownValues
    ?
    TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues
    ? ProjectorProps & {
        children(context: Readonly<TemplaterProps>): unknown
    }
    : ProjectorProps & {
        children?: Array<astroHTML.JSX.HTMLAttributes> | string;
    }
    : TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues
    ? { children?(context: Readonly<TemplaterProps>): unknown }
    : { children?: Array<astroHTML.JSX.HTMLAttributes> | string; }


declare function Templater<T, U>(props: TemplaterProps<T, U>): any

declare function Projector<T, U>(props: ProjectorProps<T, U>): any


declare function useTemplaterAndProjector<
    ProjectorProps extends StringKeyedObjectLiteralWithUnknownValues | null,
    TemplaterProps extends StringKeyedObjectLiteralWithUnknownValues | null = null
>(debugName?: string):
    [typeof Templater<ProjectorProps, TemplaterProps>, typeof Projector<TemplaterProps, ProjectorProps>]

type HasForEachMethod = {
    forEach<T>(callbackfn: (...args: Array<any>) => T, thisArg?: typeof globalThis): void;
};
type Callback = (...args: Array<any>) => any;
type GetParametersFromIterableWithAForEachMethod<T extends HasForEachMethod> = Parameters<Parameters<T["forEach"]>[0]>;
type GetAppropriateFunctionBasedOnWhetherOrNotAGeneratorOfAnIterableWithTheForEachMethodIsPassed<T, U> = T extends HasForEachMethod ? (value: GetParametersFromIterableWithAForEachMethod<T>[0], info: IterationInfo, key: GetParametersFromIterableWithAForEachMethod<T>[1]) => U : T extends Generator ? (value: ReturnType<T["next"]>["value"]) => U : never;
type IterateRangeCallback<U> = (value: number, info: IterationInfo) => U;
type IterateRangeOptions = {
    start: number;
    stop: number;
    step?: number;
    inclusive?: true;
};
declare class IterationInfo {
    private readonly firstIterationNum;
    private readonly iterationNum;
    private readonly lastIterationNum;
    constructor(firstIterationNum: number, iterationNum: number, lastIterationNum: number);
    get count(): number;
    get iteration(): number;
    get isFirst(): boolean;
    get isLast(): boolean;
    get isEven(): boolean;
    get isOdd(): boolean;
    get remaining(): number;
}

declare function executeIf<T extends Callback>(condition: unknown, cb: T): ReturnType<T> | undefined;
type IfElseOptions = {
    condition: boolean;
    ifCb: () => NonNullable<unknown>;
    elseCb: () => NonNullable<unknown>;
};
declare function executeIfElse(options: IfElseOptions): ReturnType<typeof options.ifCb> | ReturnType<typeof options.elseCb>;
declare function executeIfElse(condition: boolean, ifCb: IfElseOptions["ifCb"], elseCb: IfElseOptions["elseCb"]): ReturnType<typeof ifCb> | ReturnType<typeof elseCb>;
declare function executeUnless<T extends Callback>(condition: unknown, cb: T): asserts condition;
declare function throwIf(condition: unknown, message?: string): void;
declare function throwUnless(condition: boolean, message?: string): asserts condition;

interface GetCollections {
    <T extends ReadonlyArray<CollectionKey>, U extends CollectionEntry<T[number]>>(collectionNames: T, filter?: (entry: CollectionEntry<T[number]>) => entry is U): Promise<Array<U>>;
    <T extends ReadonlyArray<CollectionKey>>(collectionNames: T, filter?: (entry: CollectionEntry<T[number]>) => unknown): Promise<Array<CollectionEntry<T[number]>>>;
}
declare const getCollections: GetCollections;
type GetEntryBySlugFunc = typeof getEntryBySlug;
type GetEntryFunc = typeof getEntry;
type GetEntriesFunc = typeof getEntries;
type FilterFunction<T extends CollectionKey, U extends CollectionEntry<T>> = ((entry: CollectionEntry<T>) => unknown) | ((entry: CollectionEntry<T>) => entry is U);
type GetCollectionDataListFunc = <T extends CollectionKey, U extends CollectionEntry<T>>(collection: T, filter?: FilterFunction<T, U>) => Promise<Array<Pick<U, "slug"> & U["data"]>>;
type GetCollectionDataListFilterDrafts = <T extends CollectionKey, U extends EntryIsADraft<T>>(collection: T, filter?: FilterFunction<T, U>) => Promise<Array<Pick<U, "slug"> & U["data"]>>;
type GetCollectionDataListFilterNonDrafts = <T extends CollectionKey, U extends EntryIsNotADraft<T>>(collection: T, filter?: FilterFunction<T, U>) => Promise<Array<Pick<U, "slug"> & U["data"]>>;
declare const getCollectionDataList: GetCollectionDataListFunc & {
    filterNonDrafts: GetCollectionDataListFilterNonDrafts;
    filterDrafts: GetCollectionDataListFilterDrafts;
};
type GetEntryData = (collection: Parameters<GetEntryFunc>[0], slugOrId: Parameters<GetEntryFunc>[1]) => Promise<Awaited<ReturnType<GetEntryFunc>>["data"] & {
    slug: Awaited<ReturnType<GetEntryFunc>>["slug"];
}>;
type GetEntryDataBySlug = (collection: Parameters<GetEntryBySlugFunc>[0], slug: Parameters<GetEntryBySlugFunc>[1]) => Promise<Awaited<ReturnType<GetEntryBySlugFunc>>["data"] & {
    slug: Awaited<ReturnType<GetEntryBySlugFunc>>["slug"];
}>;
declare const getEntryData: GetEntryData & {
    bySlug: GetEntryDataBySlug;
};
type GetDataListFromEntries = (entries: Parameters<GetEntriesFunc>[0]) => Promise<Array<Awaited<ReturnType<GetEntriesFunc>>[number]["data"] & {
    slug: Awaited<ReturnType<GetEntriesFunc>>[number]["slug"];
}>>;
declare const getDataListFromEntries: GetDataListFromEntries;
type TypeOrArrayOfType<T> = T | Array<T>;
type MapNonStringOrNumberValuesToNever<T extends Record<string, unknown>> = {
    [K in keyof T]: T[K] extends string | number ? T[K] : never;
};
type MergeCollectionEntryDataWithEntry<T extends string> = Omit<CollectionEntry<T>, "data" | "render" | "body"> & MapNonStringOrNumberValuesToNever<CollectionEntry<T>["data"]>;
type ReturnTypeOnlyIfIItsNotAnArray<U> = U extends Array<any> ? U[number] : U;
type Prettify<T> = {
    [k in keyof T]: T[k];
} & {};
interface GetCollectionPaths {
    <T extends CollectionKey, U extends TypeOrArrayOfType<keyof MergeCollectionEntryDataWithEntry<T>>>(collection: T, by: U, filter?: (entry: CollectionEntry<T>) => unknown): Promise<Array<{
        params: Prettify<Pick<MergeCollectionEntryDataWithEntry<T>, ReturnTypeOnlyIfIItsNotAnArray<U>>>;
        props: EntryIsNotADraft<T>;
    }>>;
    <T extends CollectionKey, U extends TypeOrArrayOfType<keyof MergeCollectionEntryDataWithEntry<T>>, V extends EntryIsNotADraft<T>>(collection: T, by: U, filter?: (entry: CollectionEntry<T>) => entry is V): Promise<Array<{
        params: Prettify<Pick<MergeCollectionEntryDataWithEntry<T>, ReturnTypeOnlyIfIItsNotAnArray<U>>>;
        props: V;
    }>>;
}
declare const getCollectionPaths: GetCollectionPaths;
type EntryIsADraft<T extends CollectionKey> = Omit<CollectionEntry<T>, "data"> & {
    data: NonNullable<CollectionEntry<T>["data"] & {
        draft: true;
    }>;
};
type EntryIsNotADraft<T extends CollectionKey> = Omit<CollectionEntry<T>, "data"> & {
    data: NonNullable<CollectionEntry<T>["data"] & {
        draft: false | undefined;
    }>;
};

interface TemplateStringsArray extends ReadonlyArray<string> {
    readonly raw: readonly string[];
}
type RenderTemplateResult = Readonly<{
    htmlParts: TemplateStringsArray;
    expressions: Array<unknown>;
    error: Error;
}>;
declare const createMarkdocFunction: (cb: Callback) => {
    transform(parameters: Record<number, unknown>): any;
};
type RangeOptions = {
    step?: number;
    inclusive?: true;
};
declare function range(start: number, stop: number, options?: RangeOptions): Generator<number, void, unknown>;
declare function iterate<T extends Iterable<unknown> | Generator, U>(iterable: T, cb: GetAppropriateFunctionBasedOnWhetherOrNotAGeneratorOfAnIterableWithTheForEachMethodIsPassed<T, U>): AsyncGenerator<Awaited<U>, void, unknown>;
declare function syncIterate<T extends Iterable<unknown> | Generator, U>(iterable: T, cb: GetAppropriateFunctionBasedOnWhetherOrNotAGeneratorOfAnIterableWithTheForEachMethodIsPassed<T, U>): Generator<U, void, unknown>;
declare function iterateRange<U>(callback: IterateRangeCallback<U>, options: IterateRangeOptions): AsyncGenerator<Awaited<U>, void, unknown>;
type SlotFunction = ((...args: Array<NonNullable<unknown>>) => RenderTemplateResult) | undefined;
type MaybePromise<T extends NonNullable<unknown>> = T | Promise<T>;
type AstroRenderFunction = (props: Props, slots: Record<string, SlotFunction>) => MaybePromise<string | number | RenderTemplateResult>;
declare const createAstroFunctionalComponent: (fn: AstroRenderFunction) => ((result: SSRResult, props: Props, slots: Record<string, SlotFunction>) => {
    [Symbol.toStringTag]: string;
    [Symbol.asyncIterator](): AsyncGenerator<string | number | Readonly<{
        htmlParts: TemplateStringsArray;
        expressions: Array<unknown>;
        error: Error;
    }>, void, unknown>;
    styles: Set<astro.SSRElement>;
    scripts: Set<astro.SSRElement>;
    links: Set<astro.SSRElement>;
    componentMetadata: Map<string, astro.SSRComponentMetadata>;
    createAstro(Astro: astro.AstroGlobalPartial, props: Record<string, any>, slots: Record<string, any> | null): astro.AstroGlobal<Record<string, any>, astro_runtime_server_index_js.AstroComponentFactory, Record<string, string | undefined>>;
    resolve: (s: string) => Promise<string>;
    response: ResponseInit;
    renderers: astro.SSRLoadedRenderer[];
    clientDirectives: Map<string, string>;
    compressHTML: boolean;
    partial: boolean;
    pathname: string;
    cookies: node_modules_astro_dist_core_cookies_cookies.AstroCookies | undefined;
    _metadata: astro.SSRMetadata;
}) & {
    isAstroComponentFactory: boolean;
};
declare function returnErrorAndResultFromPromise<T extends Promise<any>>(promise: T): Promise<readonly [Awaited<T>, null] | readonly [null, Error]>;

export { type Callback, type GetAppropriateFunctionBasedOnWhetherOrNotAGeneratorOfAnIterableWithTheForEachMethodIsPassed, type HasForEachMethod, type IterateRangeCallback, type IterateRangeOptions, IterationInfo, createAstroFunctionalComponent, createMarkdocFunction, executeIf, executeIfElse, executeUnless, getCollectionDataList, getCollectionPaths, getCollections, getDataListFromEntries, getEntryData, iterate, iterateRange, range, returnErrorAndResultFromPromise, syncIterate, throwIf, throwUnless, useTemplaterAndProjector };
