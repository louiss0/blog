var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/guards.ts
function createValueGuards(values) {
  return createGuards("Value", values);
}
function createKeyGuards(keys) {
  return createGuards("Key", keys);
}
function createEntryGuards(obj, objInverted) {
  return createGuards("Entry", (entry) => {
    if (!Array.isArray(entry) || entry.length !== 2) {
      return 'Enum entry must be a tuple (e.g. ["key", "value"])';
    }
    if (!(entry[0] in obj)) {
      return `Enum key out of range (received ${JSON.stringify(
        entry[0]
      )}, expected one of: ${Object.keys(obj).map((key) => JSON.stringify(key)).join(", ")})`;
    }
    if (obj[entry[0]] !== entry[1]) {
      return `Enum key and value don't match (expected [${JSON.stringify(
        entry[0]
      )}, ${JSON.stringify(obj[entry[0]])}] or [${JSON.stringify(
        objInverted[entry[1]]
      )}, ${JSON.stringify(entry[1])}])`;
    }
    return true;
  });
}
function createGuards(kind, valuesOrPredicate) {
  const isFn = (value) => {
    if (typeof valuesOrPredicate === "function") {
      return valuesOrPredicate(value) === true;
    }
    return valuesOrPredicate.includes(value);
  };
  const assertFn = (value) => {
    if (typeof valuesOrPredicate === "function") {
      const res = valuesOrPredicate(value);
      if (typeof res === "string") {
        throw new RangeError(res);
      }
    } else {
      if (!valuesOrPredicate.includes(value)) {
        throw new RangeError(
          `Enum ${kind.toLowerCase()} out of range (received ${JSON.stringify(
            value
          )}, expected one of: ${valuesOrPredicate.map((item) => JSON.stringify(item)).join(", ")})`
        );
      }
    }
  };
  return {
    [`has${kind}`]: isFn,
    [`assert${kind}`]: assertFn
  };
}

// src/create.ts
function create(source) {
  if (Array.isArray(source)) {
    return createSimpleEnum([...source]);
  }
  return createLabeledEnum(source);
}
function createSimpleEnum(values) {
  return __spreadValues({
    accessor: Object.freeze(
      Object.fromEntries(values.map((value) => [value, value]))
    ),
    values: () => values
  }, createValueGuards(values));
}
function createLabeledEnum(obj) {
  if (Object.values(obj).some((value) => typeof value === "string") && Object.values(obj).some((value) => typeof value === "number")) {
    return createLabeledEnum(
      Object.fromEntries(
        Object.entries(obj).filter(([, value]) => typeof value === "number")
      )
    );
  }
  const objInverted = Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [value, key])
  );
  return __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({}, createSimpleEnum(Object.values(obj))), {
    keys: () => Object.keys(obj)
  }), createKeyGuards(Object.keys(obj))), {
    entries: () => Object.entries(obj)
  }), createEntryGuards(obj, objInverted)), {
    accessor: Object.freeze(obj),
    keyOf: (value) => objInverted[value]
  });
}

// src/exclude.ts
function exclude(srcEnum, items) {
  if ("keys" in srcEnum) {
    if (items.every((item) => item in srcEnum.accessor)) {
      return create(
        Object.fromEntries(
          Object.entries(srcEnum.accessor).filter(
            ([key]) => !items.includes(key)
          )
        )
      );
    }
    return create(
      Object.fromEntries(
        Object.entries(srcEnum.accessor).filter(
          ([, value]) => !items.includes(value)
        )
      )
    );
  }
  return create(srcEnum.values().filter((value) => !items.includes(value)));
}

// src/extend.ts
function extend(srcEnum, extras) {
  if (Array.isArray(extras)) {
    return create([...srcEnum.values(), ...extras]);
  }
  return create(__spreadValues(__spreadValues({}, "accessor" in srcEnum && srcEnum.accessor), extras));
}

// src/enum.ts
var Enum = Object.assign(create, { extend, exclude });
export {
  Enum
};
